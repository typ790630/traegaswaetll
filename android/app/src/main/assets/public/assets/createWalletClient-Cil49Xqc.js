import{z as R,O as Ct,P as Tt,Q as X,T as rt,U as q,V as T,X as j,Y,Z as ot,_ as it,$ as Z,a0 as ct,a1 as ut,a2 as K,s as dt,a3 as bt,a4 as P,a5 as et,a6 as qt,a7 as vt,a8 as V,a9 as nt,aa as At,ab as St,ac as st,ad as Et,ae as It,af as Pt,ag as Rt,ah as _t,ai as xt,aj as Nt,ak as zt,al as Ft,am as Mt,an as kt,ao as Dt,ap as lt,aq as Ot,ar as Lt,as as jt,at as Ut,au as Wt,av as Bt,aw as $t}from"./index-DiZJZs_I.js";class _ extends R{constructor({docsPath:t}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}}class z extends R{constructor({docsPath:t,metaMessages:e,type:s}){super(`Account type "${s}" is not supported.`,{docsPath:t,metaMessages:e,name:"AccountTypeNotSupportedError"})}}function tt({chain:a,currentChainId:t}){if(!a)throw new Ct;if(t!==a.id)throw new Tt({chain:a,currentChainId:t})}const J=new it(128);async function B(a,t){var b,U,m,M;const{account:e=a.account,assertChainId:s=!0,chain:n=a.chain,accessList:u,authorizationList:o,blobs:i,data:l,gas:C,gasPrice:r,maxFeePerBlobGas:y,maxFeePerGas:h,maxPriorityFeePerGas:c,nonce:p,type:g,value:f,...w}=t;if(typeof e>"u")throw new _({docsPath:"/docs/actions/wallet/sendTransaction"});const d=e?q(e):null;try{X(t);const v=await(async()=>{if(t.to)return t.to;if(t.to!==null&&o&&o.length>0)return await rt({authorization:o[0]}).catch(()=>{throw new R("`to` is required. Could not infer from `authorizationList`.")})})();if((d==null?void 0:d.type)==="json-rpc"||d===null){let E;n!==null&&(E=await T(a,j,"getChainId")({}),s&&tt({currentChainId:E,chain:n}));const x=(m=(U=(b=a.chain)==null?void 0:b.formatters)==null?void 0:U.transactionRequest)==null?void 0:m.format,I=(x||Y)({...ot(w,{format:x}),accessList:u,account:d,authorizationList:o,blobs:i,chainId:E,data:l,gas:C,gasPrice:r,maxFeePerBlobGas:y,maxFeePerGas:h,maxPriorityFeePerGas:c,nonce:p,to:v,type:g,value:f},"sendTransaction"),N=J.get(a.uid),W=N?"wallet_sendTransaction":"eth_sendTransaction";try{return await a.request({method:W,params:[I]},{retryCount:0})}catch(k){if(N===!1)throw k;const S=k;if(S.name==="InvalidInputRpcError"||S.name==="InvalidParamsRpcError"||S.name==="MethodNotFoundRpcError"||S.name==="MethodNotSupportedRpcError")return await a.request({method:"wallet_sendTransaction",params:[I]},{retryCount:0}).then(D=>(J.set(a.uid,!0),D)).catch(D=>{const O=D;throw O.name==="MethodNotFoundRpcError"||O.name==="MethodNotSupportedRpcError"?(J.set(a.uid,!1),S):O});throw S}}if((d==null?void 0:d.type)==="local"){const E=await T(a,Z,"prepareTransactionRequest")({account:d,accessList:u,authorizationList:o,blobs:i,chain:n,data:l,gas:C,gasPrice:r,maxFeePerBlobGas:y,maxFeePerGas:h,maxPriorityFeePerGas:c,nonce:p,nonceManager:d.nonceManager,parameters:[...ct,"sidecars"],type:g,value:f,...w,to:v}),x=(M=n==null?void 0:n.serializers)==null?void 0:M.transaction,A=await d.signTransaction(E,{serializer:x});return await T(a,ut,"sendRawTransaction")({serializedTransaction:A})}throw(d==null?void 0:d.type)==="smart"?new z({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new z({docsPath:"/docs/actions/wallet/sendTransaction",type:d==null?void 0:d.type})}catch(v){throw v instanceof z?v:K(v,{...t,account:d,chain:t.chain||void 0})}}async function L(a,t){return L.internal(a,B,"sendTransaction",t)}(function(a){async function t(e,s,n,u){const{abi:o,account:i=e.account,address:l,args:C,dataSuffix:r,functionName:y,...h}=u;if(typeof i>"u")throw new _({docsPath:"/docs/contract/writeContract"});const c=i?q(i):null,p=dt({abi:o,args:C,functionName:y});try{return await T(e,s,n)({data:`${p}${r?r.replace("0x",""):""}`,to:l,account:c,...h})}catch(g){throw bt(g,{abi:o,address:l,args:C,docsPath:"/docs/contract/writeContract",functionName:y,sender:c==null?void 0:c.address})}}a.internal=t})(L||(L={}));class Gt extends R{constructor(t){super(`Call bundle failed with status: ${t.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=t}}const ht="0x5792579257925792579257925792579257925792579257925792579257925792",ft=P(0,{size:32});async function pt(a,t){const{account:e=a.account,capabilities:s,chain:n=a.chain,experimental_fallback:u,experimental_fallbackDelay:o=32,forceAtomic:i=!1,id:l,version:C="2.0.0"}=t,r=e?q(e):null,y=t.calls.map(h=>{const c=h,p=c.abi?dt({abi:c.abi,functionName:c.functionName,args:c.args}):c.data;return{data:c.dataSuffix&&p?et([p,c.dataSuffix]):p,to:c.to,value:c.value?P(c.value):void 0}});try{const h=await a.request({method:"wallet_sendCalls",params:[{atomicRequired:i,calls:y,capabilities:s,chainId:P(n.id),from:r==null?void 0:r.address,id:l,version:C}]},{retryCount:0});return typeof h=="string"?{id:h}:h}catch(h){const c=h;if(u&&(c.name==="MethodNotFoundRpcError"||c.name==="MethodNotSupportedRpcError"||c.name==="UnknownRpcError"||c.details.toLowerCase().includes("does not exist / is not available")||c.details.toLowerCase().includes("missing or invalid. request()")||c.details.toLowerCase().includes("did not match any variant of untagged enum")||c.details.toLowerCase().includes("account upgraded to unsupported contract")||c.details.toLowerCase().includes("eip-7702 not supported")||c.details.toLowerCase().includes("unsupported wc_ method")||c.details.toLowerCase().includes("feature toggled misconfigured")||c.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(s&&Object.values(s).some(d=>!d.optional)){const d="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new qt(new R(d,{details:d}))}if(i&&y.length>1){const w="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new vt(new R(w,{details:w}))}const p=[];for(const w of y){const d=B(a,{account:r,chain:n,data:w.data,to:w.to,value:w.value?V(w.value):void 0});p.push(d),o>0&&await new Promise(b=>setTimeout(b,o))}const g=await Promise.allSettled(p);if(g.every(w=>w.status==="rejected"))throw g[0].reason;const f=g.map(w=>w.status==="fulfilled"?w.value:ft);return{id:et([...f,P(n.id,{size:32}),ht])}}throw K(h,{...t,account:r,chain:t.chain})}}async function wt(a,t){async function e(r){if(r.endsWith(ht.slice(2))){const h=St(st(r,-64,-32)),c=st(r,0,-64).slice(2).match(/.{1,64}/g),p=await Promise.all(c.map(f=>ft.slice(2)!==f?a.request({method:"eth_getTransactionReceipt",params:[`0x${f}`]},{dedupe:!0}):void 0)),g=p.some(f=>f===null)?100:p.every(f=>(f==null?void 0:f.status)==="0x1")?200:p.every(f=>(f==null?void 0:f.status)==="0x0")?500:600;return{atomic:!1,chainId:nt(h),receipts:p.filter(Boolean),status:g,version:"2.0.0"}}return a.request({method:"wallet_getCallsStatus",params:[r]})}const{atomic:s=!1,chainId:n,receipts:u,version:o="2.0.0",...i}=await e(t.id),[l,C]=(()=>{const r=i.status;return r>=100&&r<200?["pending",r]:r>=200&&r<300?["success",r]:r>=300&&r<700?["failure",r]:r==="CONFIRMED"?["success",200]:r==="PENDING"?["pending",100]:[void 0,r]})();return{...i,atomic:s,chainId:n?nt(n):void 0,receipts:(u==null?void 0:u.map(r=>({...r,blockNumber:V(r.blockNumber),gasUsed:V(r.gasUsed),status:At[r.status]})))??[],statusCode:C,status:l,version:o}}async function mt(a,t){const{id:e,pollingInterval:s=a.pollingInterval,status:n=({statusCode:g})=>g===200||g>=300,retryCount:u=4,retryDelay:o=({count:g})=>~~(1<<g)*200,timeout:i=6e4,throwOnFailure:l=!1}=t,C=Et(["waitForCallsStatus",a.uid,e]),{promise:r,resolve:y,reject:h}=It();let c;const p=Pt(C,{resolve:y,reject:h},g=>{const f=Rt(async()=>{const w=d=>{clearTimeout(c),f(),d(),p()};try{const d=await _t(async()=>{const b=await T(a,wt,"getCallsStatus")({id:e});if(l&&b.status==="failure")throw new Gt(b);return b},{retryCount:u,delay:o});if(!n(d))return;w(()=>g.resolve(d))}catch(d){w(()=>g.reject(d))}},{interval:s,emitOnBegin:!0});return f});return c=i?setTimeout(()=>{p(),clearTimeout(c),h(new Ht({id:e}))},i):void 0,await r}class Ht extends R{constructor({id:t}){super(`Timed out while waiting for call bundle with id "${t}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}async function Jt(a,{chain:t}){const{id:e,name:s,nativeCurrency:n,rpcUrls:u,blockExplorers:o}=t;await a.request({method:"wallet_addEthereumChain",params:[{chainId:P(e),chainName:s,nativeCurrency:n,rpcUrls:u.default.http,blockExplorerUrls:o?Object.values(o).map(({url:i})=>i):void 0}]},{dedupe:!0,retryCount:0})}function Qt(a,t){const{abi:e,args:s,bytecode:n,...u}=t,o=xt({abi:e,args:s,bytecode:n});return B(a,{...u,...u.authorizationList?{to:null}:{},data:o})}async function Vt(a){var e;return((e=a.account)==null?void 0:e.type)==="local"?[a.account.address]:(await a.request({method:"eth_accounts"},{dedupe:!0})).map(s=>Nt(s))}async function Xt(a,t={}){const{account:e=a.account,chainId:s}=t,n=e?q(e):void 0,u=s?[n==null?void 0:n.address,[P(s)]]:[n==null?void 0:n.address],o=await a.request({method:"wallet_getCapabilities",params:u}),i={};for(const[l,C]of Object.entries(o)){i[Number(l)]={};for(let[r,y]of Object.entries(C))r==="addSubAccount"&&(r="unstable_addSubAccount"),i[Number(l)][r]=y}return typeof s=="number"?i[s]:i}async function Yt(a){return await a.request({method:"wallet_getPermissions"},{dedupe:!0})}async function yt(a,t){var l;const{account:e=a.account,chainId:s,nonce:n}=t;if(!e)throw new _({docsPath:"/docs/eip7702/prepareAuthorization"});const u=q(e),o=(()=>{if(t.executor)return t.executor==="self"?t.executor:q(t.executor)})(),i={address:t.contractAddress??t.address,chainId:s,nonce:n};return typeof i.chainId>"u"&&(i.chainId=((l=a.chain)==null?void 0:l.id)??await T(a,j,"getChainId")({})),typeof i.nonce>"u"&&(i.nonce=await T(a,zt,"getTransactionCount")({address:u.address,blockTag:"pending"}),(o==="self"||o!=null&&o.address&&Ft(o.address,u.address))&&(i.nonce+=1)),i}async function Zt(a){return(await a.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(e=>Mt(e))}async function Kt(a,t){return a.request({method:"wallet_requestPermissions",params:[t]},{retryCount:0})}async function ta(a,t){const{chain:e=a.chain}=t,s=t.timeout??Math.max(((e==null?void 0:e.blockTime)??0)*3,5e3),n=await pt(a,t);return await mt(a,{...t,id:n.id,timeout:s})}const Q=new it(128);async function gt(a,t){var M,v,E,x;const{account:e=a.account,assertChainId:s=!0,chain:n=a.chain,accessList:u,authorizationList:o,blobs:i,data:l,gas:C,gasPrice:r,maxFeePerBlobGas:y,maxFeePerGas:h,maxPriorityFeePerGas:c,nonce:p,pollingInterval:g,throwOnReceiptRevert:f,type:w,value:d,...b}=t,U=t.timeout??Math.max(((n==null?void 0:n.blockTime)??0)*3,5e3);if(typeof e>"u")throw new _({docsPath:"/docs/actions/wallet/sendTransactionSync"});const m=e?q(e):null;try{X(t);const A=await(async()=>{if(t.to)return t.to;if(t.to!==null&&o&&o.length>0)return await rt({authorization:o[0]}).catch(()=>{throw new R("`to` is required. Could not infer from `authorizationList`.")})})();if((m==null?void 0:m.type)==="json-rpc"||m===null){let I;n!==null&&(I=await T(a,j,"getChainId")({}),s&&tt({currentChainId:I,chain:n}));const N=(E=(v=(M=a.chain)==null?void 0:M.formatters)==null?void 0:v.transactionRequest)==null?void 0:E.format,k=(N||Y)({...ot(b,{format:N}),accessList:u,account:m,authorizationList:o,blobs:i,chainId:I,data:l,gas:C,gasPrice:r,maxFeePerBlobGas:y,maxFeePerGas:h,maxPriorityFeePerGas:c,nonce:p,to:A,type:w,value:d},"sendTransaction"),S=Q.get(a.uid),D=S?"wallet_sendTransaction":"eth_sendTransaction",O=await(async()=>{try{return await a.request({method:D,params:[k]},{retryCount:0})}catch(at){if(S===!1)throw at;const F=at;if(F.name==="InvalidInputRpcError"||F.name==="InvalidParamsRpcError"||F.name==="MethodNotFoundRpcError"||F.name==="MethodNotSupportedRpcError")return await a.request({method:"wallet_sendTransaction",params:[k]},{retryCount:0}).then(G=>(Q.set(a.uid,!0),G)).catch(G=>{const H=G;throw H.name==="MethodNotFoundRpcError"||H.name==="MethodNotSupportedRpcError"?(Q.set(a.uid,!1),F):H});throw F}})(),$=await T(a,kt,"waitForTransactionReceipt")({checkReplacement:!1,hash:O,pollingInterval:g,timeout:U});if(f&&$.status==="reverted")throw new Dt({receipt:$});return $}if((m==null?void 0:m.type)==="local"){const I=await T(a,Z,"prepareTransactionRequest")({account:m,accessList:u,authorizationList:o,blobs:i,chain:n,data:l,gas:C,gasPrice:r,maxFeePerBlobGas:y,maxFeePerGas:h,maxPriorityFeePerGas:c,nonce:p,nonceManager:m.nonceManager,parameters:[...ct,"sidecars"],type:w,value:d,...b,to:A}),N=(x=n==null?void 0:n.serializers)==null?void 0:x.transaction,W=await m.signTransaction(I,{serializer:N});return await T(a,lt,"sendRawTransactionSync")({serializedTransaction:W,throwOnReceiptRevert:f,timeout:t.timeout})}throw(m==null?void 0:m.type)==="smart"?new z({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new z({docsPath:"/docs/actions/wallet/sendTransactionSync",type:m==null?void 0:m.type})}catch(A){throw A instanceof z?A:K(A,{...t,account:m,chain:t.chain||void 0})}}async function aa(a,t){const{id:e}=t;await a.request({method:"wallet_showCallsStatus",params:[e]})}async function ea(a,t){const{account:e=a.account}=t;if(!e)throw new _({docsPath:"/docs/eip7702/signAuthorization"});const s=q(e);if(!s.signAuthorization)throw new z({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:s.type});const n=await yt(a,t);return s.signAuthorization(n)}async function na(a,{account:t=a.account,message:e}){if(!t)throw new _({docsPath:"/docs/actions/wallet/signMessage"});const s=q(t);if(s.signMessage)return s.signMessage({message:e});const n=typeof e=="string"?Ot(e):e.raw instanceof Uint8Array?Lt(e.raw):e.raw;return a.request({method:"personal_sign",params:[n,s.address]},{retryCount:0})}async function sa(a,t){var C,r,y,h;const{account:e=a.account,chain:s=a.chain,...n}=t;if(!e)throw new _({docsPath:"/docs/actions/wallet/signTransaction"});const u=q(e);X({account:u,...t});const o=await T(a,j,"getChainId")({});s!==null&&tt({currentChainId:o,chain:s});const i=(s==null?void 0:s.formatters)||((C=a.chain)==null?void 0:C.formatters),l=((r=i==null?void 0:i.transactionRequest)==null?void 0:r.format)||Y;return u.signTransaction?u.signTransaction({...n,chainId:o},{serializer:(h=(y=a.chain)==null?void 0:y.serializers)==null?void 0:h.transaction}):await a.request({method:"eth_signTransaction",params:[{...l({...n,account:u},"signTransaction"),chainId:P(o),from:u.address}]},{retryCount:0})}async function ra(a,t){const{account:e=a.account,domain:s,message:n,primaryType:u}=t;if(!e)throw new _({docsPath:"/docs/actions/wallet/signTypedData"});const o=q(e),i={EIP712Domain:jt({domain:s}),...t.types};if(Ut({domain:s,message:n,primaryType:u,types:i}),o.signTypedData)return o.signTypedData({domain:s,message:n,primaryType:u,types:i});const l=Wt({domain:s,message:n,primaryType:u,types:i});return a.request({method:"eth_signTypedData_v4",params:[o.address,l]},{retryCount:0})}async function oa(a,{id:t}){await a.request({method:"wallet_switchEthereumChain",params:[{chainId:P(t)}]},{retryCount:0})}async function ia(a,t){return await a.request({method:"wallet_watchAsset",params:t},{retryCount:0})}async function ca(a,t){return L.internal(a,gt,"sendTransactionSync",t)}function ua(a){return{addChain:t=>Jt(a,t),deployContract:t=>Qt(a,t),fillTransaction:t=>Bt(a,t),getAddresses:()=>Vt(a),getCallsStatus:t=>wt(a,t),getCapabilities:t=>Xt(a,t),getChainId:()=>j(a),getPermissions:()=>Yt(a),prepareAuthorization:t=>yt(a,t),prepareTransactionRequest:t=>Z(a,t),requestAddresses:()=>Zt(a),requestPermissions:t=>Kt(a,t),sendCalls:t=>pt(a,t),sendCallsSync:t=>ta(a,t),sendRawTransaction:t=>ut(a,t),sendRawTransactionSync:t=>lt(a,t),sendTransaction:t=>B(a,t),sendTransactionSync:t=>gt(a,t),showCallsStatus:t=>aa(a,t),signAuthorization:t=>ea(a,t),signMessage:t=>na(a,t),signTransaction:t=>sa(a,t),signTypedData:t=>ra(a,t),switchChain:t=>oa(a,t),waitForCallsStatus:t=>mt(a,t),watchAsset:t=>ia(a,t),writeContract:t=>L(a,t),writeContractSync:t=>ca(a,t)}}function la(a){const{key:t="wallet",name:e="Wallet Client",transport:s}=a;return $t({...a,key:t,name:e,transport:s,type:"walletClient"}).extend(ua)}export{la as c};
