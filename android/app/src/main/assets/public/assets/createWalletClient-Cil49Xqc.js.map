{"version":3,"file":"createWalletClient-Cil49Xqc.js","sources":["../../node_modules/viem/_esm/errors/account.js","../../node_modules/viem/_esm/utils/chain/assertCurrentChain.js","../../node_modules/viem/_esm/actions/wallet/sendTransaction.js","../../node_modules/viem/_esm/actions/wallet/writeContract.js","../../node_modules/viem/_esm/errors/calls.js","../../node_modules/viem/_esm/actions/wallet/sendCalls.js","../../node_modules/viem/_esm/actions/wallet/getCallsStatus.js","../../node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js","../../node_modules/viem/_esm/actions/wallet/addChain.js","../../node_modules/viem/_esm/actions/wallet/deployContract.js","../../node_modules/viem/_esm/actions/wallet/getAddresses.js","../../node_modules/viem/_esm/actions/wallet/getCapabilities.js","../../node_modules/viem/_esm/actions/wallet/getPermissions.js","../../node_modules/viem/_esm/actions/wallet/prepareAuthorization.js","../../node_modules/viem/_esm/actions/wallet/requestAddresses.js","../../node_modules/viem/_esm/actions/wallet/requestPermissions.js","../../node_modules/viem/_esm/actions/wallet/sendCallsSync.js","../../node_modules/viem/_esm/actions/wallet/sendTransactionSync.js","../../node_modules/viem/_esm/actions/wallet/showCallsStatus.js","../../node_modules/viem/_esm/actions/wallet/signAuthorization.js","../../node_modules/viem/_esm/actions/wallet/signMessage.js","../../node_modules/viem/_esm/actions/wallet/signTransaction.js","../../node_modules/viem/_esm/actions/wallet/signTypedData.js","../../node_modules/viem/_esm/actions/wallet/switchChain.js","../../node_modules/viem/_esm/actions/wallet/watchAsset.js","../../node_modules/viem/_esm/actions/wallet/writeContractSync.js","../../node_modules/viem/_esm/clients/decorators/wallet.js","../../node_modules/viem/_esm/clients/createWalletClient.js"],"sourcesContent":["import { BaseError } from './base.js';\nexport class AccountNotFoundError extends BaseError {\n    constructor({ docsPath } = {}) {\n        super([\n            'Could not find an Account to execute with this Action.',\n            'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',\n        ].join('\\n'), {\n            docsPath,\n            docsSlug: 'account',\n            name: 'AccountNotFoundError',\n        });\n    }\n}\nexport class AccountTypeNotSupportedError extends BaseError {\n    constructor({ docsPath, metaMessages, type, }) {\n        super(`Account type \"${type}\" is not supported.`, {\n            docsPath,\n            metaMessages,\n            name: 'AccountTypeNotSupportedError',\n        });\n    }\n}\n//# sourceMappingURL=account.js.map","import { ChainMismatchError, ChainNotFoundError, } from '../../errors/chain.js';\nexport function assertCurrentChain({ chain, currentChainId, }) {\n    if (!chain)\n        throw new ChainNotFoundError();\n    if (currentChainId !== chain.id)\n        throw new ChainMismatchError({ chain, currentChainId });\n}\n//# sourceMappingURL=assertCurrentChain.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, AccountTypeNotSupportedError, } from '../../errors/account.js';\nimport { BaseError } from '../../errors/base.js';\nimport { recoverAuthorizationAddress, } from '../../utils/authorization/recoverAuthorizationAddress.js';\nimport { assertCurrentChain, } from '../../utils/chain/assertCurrentChain.js';\nimport { getTransactionError, } from '../../utils/errors/getTransactionError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { LruMap } from '../../utils/lru.js';\nimport { assertRequest, } from '../../utils/transaction/assertRequest.js';\nimport { getChainId } from '../public/getChainId.js';\nimport { defaultParameters, prepareTransactionRequest, } from './prepareTransactionRequest.js';\nimport { sendRawTransaction, } from './sendRawTransaction.js';\nconst supportsWalletNamespace = new LruMap(128);\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction(client, parameters) {\n    const { account: account_ = client.account, assertChainId = true, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;\n    if (typeof account_ === 'undefined')\n        throw new AccountNotFoundError({\n            docsPath: '/docs/actions/wallet/sendTransaction',\n        });\n    const account = account_ ? parseAccount(account_) : null;\n    try {\n        assertRequest(parameters);\n        const to = await (async () => {\n            // If `to` exists on the parameters, use that.\n            if (parameters.to)\n                return parameters.to;\n            // If `to` is null, we are sending a deployment transaction.\n            if (parameters.to === null)\n                return undefined;\n            // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n            // address of the first authorization in the list.\n            if (authorizationList && authorizationList.length > 0)\n                return await recoverAuthorizationAddress({\n                    authorization: authorizationList[0],\n                }).catch(() => {\n                    throw new BaseError('`to` is required. Could not infer from `authorizationList`.');\n                });\n            // Otherwise, we are sending a deployment transaction.\n            return undefined;\n        })();\n        if (account?.type === 'json-rpc' || account === null) {\n            let chainId;\n            if (chain !== null) {\n                chainId = await getAction(client, getChainId, 'getChainId')({});\n                if (assertChainId)\n                    assertCurrentChain({\n                        currentChainId: chainId,\n                        chain,\n                    });\n            }\n            const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n            const format = chainFormat || formatTransactionRequest;\n            const request = format({\n                // Pick out extra data that might exist on the chain's transaction request type.\n                ...extract(rest, { format: chainFormat }),\n                accessList,\n                account,\n                authorizationList,\n                blobs,\n                chainId,\n                data,\n                gas,\n                gasPrice,\n                maxFeePerBlobGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                nonce,\n                to,\n                type,\n                value,\n            }, 'sendTransaction');\n            const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);\n            const method = isWalletNamespaceSupported\n                ? 'wallet_sendTransaction'\n                : 'eth_sendTransaction';\n            try {\n                return await client.request({\n                    method,\n                    params: [request],\n                }, { retryCount: 0 });\n            }\n            catch (e) {\n                if (isWalletNamespaceSupported === false)\n                    throw e;\n                const error = e;\n                // If the transport does not support the method or input, attempt to use the\n                // `wallet_sendTransaction` method.\n                if (error.name === 'InvalidInputRpcError' ||\n                    error.name === 'InvalidParamsRpcError' ||\n                    error.name === 'MethodNotFoundRpcError' ||\n                    error.name === 'MethodNotSupportedRpcError') {\n                    return await client\n                        .request({\n                        method: 'wallet_sendTransaction',\n                        params: [request],\n                    }, { retryCount: 0 })\n                        .then((hash) => {\n                        supportsWalletNamespace.set(client.uid, true);\n                        return hash;\n                    })\n                        .catch((e) => {\n                        const walletNamespaceError = e;\n                        if (walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                            walletNamespaceError.name === 'MethodNotSupportedRpcError') {\n                            supportsWalletNamespace.set(client.uid, false);\n                            throw error;\n                        }\n                        throw walletNamespaceError;\n                    });\n                }\n                throw error;\n            }\n        }\n        if (account?.type === 'local') {\n            // Prepare the request for signing (assign appropriate fees, etc.)\n            const request = await getAction(client, prepareTransactionRequest, 'prepareTransactionRequest')({\n                account,\n                accessList,\n                authorizationList,\n                blobs,\n                chain,\n                data,\n                gas,\n                gasPrice,\n                maxFeePerBlobGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                nonce,\n                nonceManager: account.nonceManager,\n                parameters: [...defaultParameters, 'sidecars'],\n                type,\n                value,\n                ...rest,\n                to,\n            });\n            const serializer = chain?.serializers?.transaction;\n            const serializedTransaction = (await account.signTransaction(request, {\n                serializer,\n            }));\n            return await getAction(client, sendRawTransaction, 'sendRawTransaction')({\n                serializedTransaction,\n            });\n        }\n        if (account?.type === 'smart')\n            throw new AccountTypeNotSupportedError({\n                metaMessages: [\n                    'Consider using the `sendUserOperation` Action instead.',\n                ],\n                docsPath: '/docs/actions/bundler/sendUserOperation',\n                type: 'smart',\n            });\n        throw new AccountTypeNotSupportedError({\n            docsPath: '/docs/actions/wallet/sendTransaction',\n            type: account?.type,\n        });\n    }\n    catch (err) {\n        if (err instanceof AccountTypeNotSupportedError)\n            throw err;\n        throw getTransactionError(err, {\n            ...parameters,\n            account,\n            chain: parameters.chain || undefined,\n        });\n    }\n}\n//# sourceMappingURL=sendTransaction.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, } from '../../errors/account.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError, } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { sendTransaction, } from './sendTransaction.js';\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract(client, parameters) {\n    return writeContract.internal(client, sendTransaction, 'sendTransaction', parameters);\n}\n(function (writeContract) {\n    async function internal(client, actionFn, name, parameters) {\n        const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;\n        if (typeof account_ === 'undefined')\n            throw new AccountNotFoundError({\n                docsPath: '/docs/contract/writeContract',\n            });\n        const account = account_ ? parseAccount(account_) : null;\n        const data = encodeFunctionData({\n            abi,\n            args,\n            functionName,\n        });\n        try {\n            return await getAction(client, actionFn, name)({\n                data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n                to: address,\n                account,\n                ...request,\n            });\n        }\n        catch (error) {\n            throw getContractError(error, {\n                abi,\n                address,\n                args,\n                docsPath: '/docs/contract/writeContract',\n                functionName,\n                sender: account?.address,\n            });\n        }\n    }\n    writeContract.internal = internal;\n})(writeContract || (writeContract = {}));\n//# sourceMappingURL=writeContract.js.map","import { BaseError } from './base.js';\nexport class BundleFailedError extends BaseError {\n    constructor(result) {\n        super(`Call bundle failed with status: ${result.statusCode}`, {\n            name: 'BundleFailedError',\n        });\n        Object.defineProperty(this, \"result\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.result = result;\n    }\n}\n//# sourceMappingURL=calls.js.map","import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { BaseError } from '../../errors/base.js';\nimport { AtomicityNotSupportedError, UnsupportedNonOptionalCapabilityError, } from '../../errors/rpc.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { concat } from '../../utils/data/concat.js';\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js';\nimport { sendTransaction } from './sendTransaction.js';\nexport const fallbackMagicIdentifier = '0x5792579257925792579257925792579257925792579257925792579257925792';\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n    size: 32,\n});\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls(client, parameters) {\n    const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id, version = '2.0.0', } = parameters;\n    const account = account_ ? parseAccount(account_) : null;\n    const calls = parameters.calls.map((call_) => {\n        const call = call_;\n        const data = call.abi\n            ? encodeFunctionData({\n                abi: call.abi,\n                functionName: call.functionName,\n                args: call.args,\n            })\n            : call.data;\n        return {\n            data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n            to: call.to,\n            value: call.value ? numberToHex(call.value) : undefined,\n        };\n    });\n    try {\n        const response = await client.request({\n            method: 'wallet_sendCalls',\n            params: [\n                {\n                    atomicRequired: forceAtomic,\n                    calls,\n                    capabilities,\n                    chainId: numberToHex(chain.id),\n                    from: account?.address,\n                    id,\n                    version,\n                },\n            ],\n        }, { retryCount: 0 });\n        if (typeof response === 'string')\n            return { id: response };\n        return response;\n    }\n    catch (err) {\n        const error = err;\n        // If the transport does not support EIP-5792, fall back to\n        // `eth_sendTransaction`.\n        if (experimental_fallback &&\n            (error.name === 'MethodNotFoundRpcError' ||\n                error.name === 'MethodNotSupportedRpcError' ||\n                error.name === 'UnknownRpcError' ||\n                error.details\n                    .toLowerCase()\n                    .includes('does not exist / is not available') ||\n                error.details.toLowerCase().includes('missing or invalid. request()') ||\n                error.details\n                    .toLowerCase()\n                    .includes('did not match any variant of untagged enum') ||\n                error.details\n                    .toLowerCase()\n                    .includes('account upgraded to unsupported contract') ||\n                error.details.toLowerCase().includes('eip-7702 not supported') ||\n                error.details.toLowerCase().includes('unsupported wc_ method') ||\n                // magic.link\n                error.details\n                    .toLowerCase()\n                    .includes('feature toggled misconfigured') ||\n                // Trust Wallet\n                error.details\n                    .toLowerCase()\n                    .includes('jsonrpcengine: response has no error or result for request'))) {\n            if (capabilities) {\n                const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);\n                if (hasNonOptionalCapability) {\n                    const message = 'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.';\n                    throw new UnsupportedNonOptionalCapabilityError(new BaseError(message, {\n                        details: message,\n                    }));\n                }\n            }\n            if (forceAtomic && calls.length > 1) {\n                const message = '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.';\n                throw new AtomicityNotSupportedError(new BaseError(message, {\n                    details: message,\n                }));\n            }\n            const promises = [];\n            for (const call of calls) {\n                const promise = sendTransaction(client, {\n                    account,\n                    chain,\n                    data: call.data,\n                    to: call.to,\n                    value: call.value ? hexToBigInt(call.value) : undefined,\n                });\n                promises.push(promise);\n                // Note: some browser wallets require a small delay between transactions\n                // to prevent duplicate JSON-RPC requests.\n                if (experimental_fallbackDelay > 0)\n                    await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));\n            }\n            const results = await Promise.allSettled(promises);\n            if (results.every((r) => r.status === 'rejected'))\n                throw results[0].reason;\n            const hashes = results.map((result) => {\n                if (result.status === 'fulfilled')\n                    return result.value;\n                return fallbackTransactionErrorMagicIdentifier;\n            });\n            return {\n                id: concat([\n                    ...hashes,\n                    numberToHex(chain.id, { size: 32 }),\n                    fallbackMagicIdentifier,\n                ]),\n            };\n        }\n        throw getTransactionError(err, {\n            ...parameters,\n            account,\n            chain: parameters.chain,\n        });\n    }\n}\n//# sourceMappingURL=sendCalls.js.map","import { sliceHex } from '../../utils/data/slice.js';\nimport { trim } from '../../utils/data/trim.js';\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js';\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js';\nimport { fallbackMagicIdentifier, fallbackTransactionErrorMagicIdentifier, } from './sendCalls.js';\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus(client, parameters) {\n    async function getStatus(id) {\n        const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2));\n        if (isTransactions) {\n            const chainId = trim(sliceHex(id, -64, -32));\n            const hashes = sliceHex(id, 0, -64)\n                .slice(2)\n                .match(/.{1,64}/g);\n            const receipts = await Promise.all(hashes.map((hash) => fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n                ? client.request({\n                    method: 'eth_getTransactionReceipt',\n                    params: [`0x${hash}`],\n                }, { dedupe: true })\n                : undefined));\n            const status = (() => {\n                if (receipts.some((r) => r === null))\n                    return 100; // pending\n                if (receipts.every((r) => r?.status === '0x1'))\n                    return 200; // success\n                if (receipts.every((r) => r?.status === '0x0'))\n                    return 500; // complete failure\n                return 600; // partial failure\n            })();\n            return {\n                atomic: false,\n                chainId: hexToNumber(chainId),\n                receipts: receipts.filter(Boolean),\n                status,\n                version: '2.0.0',\n            };\n        }\n        return client.request({\n            method: 'wallet_getCallsStatus',\n            params: [id],\n        });\n    }\n    const { atomic = false, chainId, receipts, version = '2.0.0', ...response } = await getStatus(parameters.id);\n    const [status, statusCode] = (() => {\n        const statusCode = response.status;\n        if (statusCode >= 100 && statusCode < 200)\n            return ['pending', statusCode];\n        if (statusCode >= 200 && statusCode < 300)\n            return ['success', statusCode];\n        if (statusCode >= 300 && statusCode < 700)\n            return ['failure', statusCode];\n        // @ts-expect-error: for backwards compatibility\n        if (statusCode === 'CONFIRMED')\n            return ['success', 200];\n        // @ts-expect-error: for backwards compatibility\n        if (statusCode === 'PENDING')\n            return ['pending', 100];\n        return [undefined, statusCode];\n    })();\n    return {\n        ...response,\n        atomic,\n        // @ts-expect-error: for backwards compatibility\n        chainId: chainId ? hexToNumber(chainId) : undefined,\n        receipts: receipts?.map((receipt) => ({\n            ...receipt,\n            blockNumber: hexToBigInt(receipt.blockNumber),\n            gasUsed: hexToBigInt(receipt.gasUsed),\n            status: receiptStatuses[receipt.status],\n        })) ?? [],\n        statusCode,\n        status,\n        version,\n    };\n}\n//# sourceMappingURL=getCallsStatus.js.map","import { BaseError } from '../../errors/base.js';\nimport { BundleFailedError } from '../../errors/calls.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry, } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getCallsStatus, } from './getCallsStatus.js';\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus(client, parameters) {\n    const { id, pollingInterval = client.pollingInterval, status = ({ statusCode }) => statusCode === 200 || statusCode >= 300, retryCount = 4, retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000, throwOnFailure = false, } = parameters;\n    const observerId = stringify(['waitForCallsStatus', client.uid, id]);\n    const { promise, resolve, reject } = withResolvers();\n    let timer;\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n        const unpoll = poll(async () => {\n            const done = (fn) => {\n                clearTimeout(timer);\n                unpoll();\n                fn();\n                unobserve();\n            };\n            try {\n                const result = await withRetry(async () => {\n                    const result = await getAction(client, getCallsStatus, 'getCallsStatus')({ id });\n                    if (throwOnFailure && result.status === 'failure')\n                        throw new BundleFailedError(result);\n                    return result;\n                }, {\n                    retryCount,\n                    delay: retryDelay,\n                });\n                if (!status(result))\n                    return;\n                done(() => emit.resolve(result));\n            }\n            catch (error) {\n                done(() => emit.reject(error));\n            }\n        }, {\n            interval: pollingInterval,\n            emitOnBegin: true,\n        });\n        return unpoll;\n    });\n    timer = timeout\n        ? setTimeout(() => {\n            unobserve();\n            clearTimeout(timer);\n            reject(new WaitForCallsStatusTimeoutError({ id }));\n        }, timeout)\n        : undefined;\n    return await promise;\n}\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n    constructor({ id }) {\n        super(`Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`, { name: 'WaitForCallsStatusTimeoutError' });\n    }\n}\n//# sourceMappingURL=waitForCallsStatus.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/addChain\n * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n *\n * @param client - Client to use\n * @param parameters - {@link AddChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { addChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   transport: custom(window.ethereum),\n * })\n * await addChain(client, { chain: optimism })\n */\nexport async function addChain(client, { chain }) {\n    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;\n    await client.request({\n        method: 'wallet_addEthereumChain',\n        params: [\n            {\n                chainId: numberToHex(id),\n                chainName: name,\n                nativeCurrency,\n                rpcUrls: rpcUrls.default.http,\n                blockExplorerUrls: blockExplorers\n                    ? Object.values(blockExplorers).map(({ url }) => url)\n                    : undefined,\n            },\n        ],\n    }, { dedupe: true, retryCount: 0 });\n}\n//# sourceMappingURL=addChain.js.map","import { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { sendTransaction, } from './sendTransaction.js';\n/**\n * Deploys a contract to the network, given bytecode and constructor arguments.\n *\n * - Docs: https://viem.sh/docs/contract/deployContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts\n *\n * @param client - Client to use\n * @param parameters - {@link DeployContractParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}\n *\n * @example\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { deployContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await deployContract(client, {\n *   abi: [],\n *   account: '0x…,\n *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n * })\n */\nexport function deployContract(walletClient, parameters) {\n    const { abi, args, bytecode, ...request } = parameters;\n    const calldata = encodeDeployData({ abi, args, bytecode });\n    return sendTransaction(walletClient, {\n        ...request,\n        ...(request.authorizationList ? { to: null } : {}),\n        data: calldata,\n    });\n}\n//# sourceMappingURL=deployContract.js.map","import { checksumAddress, } from '../../utils/address/getAddress.js';\n/**\n * Returns a list of account addresses owned by the wallet or client.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getAddresses\n * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n *\n * @param client - Client to use\n * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await getAddresses(client)\n */\nexport async function getAddresses(client) {\n    if (client.account?.type === 'local')\n        return [client.account.address];\n    const addresses = await client.request({ method: 'eth_accounts' }, { dedupe: true });\n    return addresses.map((address) => checksumAddress(address));\n}\n//# sourceMappingURL=getAddresses.js.map","import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\n/**\n * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities\n * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCapabilities } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const capabilities = await getCapabilities(client)\n */\nexport async function getCapabilities(client, parameters = {}) {\n    const { account = client.account, chainId } = parameters;\n    const account_ = account ? parseAccount(account) : undefined;\n    const params = chainId\n        ? [account_?.address, [numberToHex(chainId)]]\n        : [account_?.address];\n    const capabilities_raw = await client.request({\n        method: 'wallet_getCapabilities',\n        params,\n    });\n    const capabilities = {};\n    for (const [chainId, capabilities_] of Object.entries(capabilities_raw)) {\n        capabilities[Number(chainId)] = {};\n        for (let [key, value] of Object.entries(capabilities_)) {\n            if (key === 'addSubAccount')\n                key = 'unstable_addSubAccount';\n            capabilities[Number(chainId)][key] = value;\n        }\n    }\n    return (typeof chainId === 'number' ? capabilities[chainId] : capabilities);\n}\n//# sourceMappingURL=getCapabilities.js.map","/**\n * Gets the wallets current permissions.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getPermissions\n * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @returns The wallet permissions. {@link GetPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await getPermissions(client)\n */\nexport async function getPermissions(client) {\n    const permissions = await client.request({ method: 'wallet_getPermissions' }, { dedupe: true });\n    return permissions;\n}\n//# sourceMappingURL=getPermissions.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, } from '../../errors/account.js';\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { getChainId } from '../public/getChainId.js';\nimport { getTransactionCount } from '../public/getTransactionCount.js';\n/**\n * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n *\n * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link PrepareAuthorizationParameters}\n * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function prepareAuthorization(client, parameters) {\n    const { account: account_ = client.account, chainId, nonce } = parameters;\n    if (!account_)\n        throw new AccountNotFoundError({\n            docsPath: '/docs/eip7702/prepareAuthorization',\n        });\n    const account = parseAccount(account_);\n    const executor = (() => {\n        if (!parameters.executor)\n            return undefined;\n        if (parameters.executor === 'self')\n            return parameters.executor;\n        return parseAccount(parameters.executor);\n    })();\n    const authorization = {\n        address: parameters.contractAddress ?? parameters.address,\n        chainId,\n        nonce,\n    };\n    if (typeof authorization.chainId === 'undefined')\n        authorization.chainId =\n            client.chain?.id ??\n                (await getAction(client, getChainId, 'getChainId')({}));\n    if (typeof authorization.nonce === 'undefined') {\n        authorization.nonce = await getAction(client, getTransactionCount, 'getTransactionCount')({\n            address: account.address,\n            blockTag: 'pending',\n        });\n        if (executor === 'self' ||\n            (executor?.address && isAddressEqual(executor.address, account.address)))\n            authorization.nonce += 1;\n    }\n    return authorization;\n}\n//# sourceMappingURL=prepareAuthorization.js.map","import { getAddress } from '../../utils/address/getAddress.js';\n/**\n * Requests a list of accounts managed by a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses\n * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n *\n * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n *\n * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n *\n * @param client - Client to use\n * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await requestAddresses(client)\n */\nexport async function requestAddresses(client) {\n    const addresses = await client.request({ method: 'eth_requestAccounts' }, { dedupe: true, retryCount: 0 });\n    return addresses.map((address) => getAddress(address));\n}\n//# sourceMappingURL=requestAddresses.js.map","/**\n * Requests permissions for a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions\n * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @param parameters - {@link RequestPermissionsParameters}\n * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await requestPermissions(client, {\n *   eth_accounts: {}\n * })\n */\nexport async function requestPermissions(client, permissions) {\n    return client.request({\n        method: 'wallet_requestPermissions',\n        params: [permissions],\n    }, { retryCount: 0 });\n}\n//# sourceMappingURL=requestPermissions.js.map","import { sendCalls, } from './sendCalls.js';\nimport { waitForCallsStatus, } from './waitForCallsStatus.js';\n/**\n * Requests the connected wallet to send a batch of calls, and waits for the calls to be included in a block.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCallsSync\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Calls status. {@link SendCallsSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const status = await sendCallsSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCallsSync(client, parameters) {\n    const { chain = client.chain } = parameters;\n    const timeout = parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000);\n    const result = await sendCalls(client, parameters);\n    const status = await waitForCallsStatus(client, {\n        ...parameters,\n        id: result.id,\n        timeout,\n    });\n    return status;\n}\n//# sourceMappingURL=sendCallsSync.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, AccountTypeNotSupportedError, } from '../../errors/account.js';\nimport { BaseError } from '../../errors/base.js';\nimport { TransactionReceiptRevertedError, } from '../../errors/transaction.js';\nimport { recoverAuthorizationAddress, } from '../../utils/authorization/recoverAuthorizationAddress.js';\nimport { assertCurrentChain, } from '../../utils/chain/assertCurrentChain.js';\nimport { getTransactionError, } from '../../utils/errors/getTransactionError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { LruMap } from '../../utils/lru.js';\nimport { assertRequest, } from '../../utils/transaction/assertRequest.js';\nimport { getChainId } from '../public/getChainId.js';\nimport { waitForTransactionReceipt, } from '../public/waitForTransactionReceipt.js';\nimport { defaultParameters, prepareTransactionRequest, } from './prepareTransactionRequest.js';\nimport { sendRawTransactionSync, } from './sendRawTransactionSync.js';\nconst supportsWalletNamespace = new LruMap(128);\n/**\n * Creates, signs, and sends a new transaction to the network synchronously.\n * Returns the transaction receipt.\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionSyncParameters}\n * @returns The transaction receipt. {@link SendTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransactionSync(client, parameters) {\n    const { account: account_ = client.account, assertChainId = true, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, pollingInterval, throwOnReceiptRevert, type, value, ...rest } = parameters;\n    const timeout = parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000);\n    if (typeof account_ === 'undefined')\n        throw new AccountNotFoundError({\n            docsPath: '/docs/actions/wallet/sendTransactionSync',\n        });\n    const account = account_ ? parseAccount(account_) : null;\n    try {\n        assertRequest(parameters);\n        const to = await (async () => {\n            // If `to` exists on the parameters, use that.\n            if (parameters.to)\n                return parameters.to;\n            // If `to` is null, we are sending a deployment transaction.\n            if (parameters.to === null)\n                return undefined;\n            // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n            // address of the first authorization in the list.\n            if (authorizationList && authorizationList.length > 0)\n                return await recoverAuthorizationAddress({\n                    authorization: authorizationList[0],\n                }).catch(() => {\n                    throw new BaseError('`to` is required. Could not infer from `authorizationList`.');\n                });\n            // Otherwise, we are sending a deployment transaction.\n            return undefined;\n        })();\n        if (account?.type === 'json-rpc' || account === null) {\n            let chainId;\n            if (chain !== null) {\n                chainId = await getAction(client, getChainId, 'getChainId')({});\n                if (assertChainId)\n                    assertCurrentChain({\n                        currentChainId: chainId,\n                        chain,\n                    });\n            }\n            const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n            const format = chainFormat || formatTransactionRequest;\n            const request = format({\n                // Pick out extra data that might exist on the chain's transaction request type.\n                ...extract(rest, { format: chainFormat }),\n                accessList,\n                account,\n                authorizationList,\n                blobs,\n                chainId,\n                data,\n                gas,\n                gasPrice,\n                maxFeePerBlobGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                nonce,\n                to,\n                type,\n                value,\n            }, 'sendTransaction');\n            const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);\n            const method = isWalletNamespaceSupported\n                ? 'wallet_sendTransaction'\n                : 'eth_sendTransaction';\n            const hash = await (async () => {\n                try {\n                    return await client.request({\n                        method,\n                        params: [request],\n                    }, { retryCount: 0 });\n                }\n                catch (e) {\n                    if (isWalletNamespaceSupported === false)\n                        throw e;\n                    const error = e;\n                    // If the transport does not support the method or input, attempt to use the\n                    // `wallet_sendTransaction` method.\n                    if (error.name === 'InvalidInputRpcError' ||\n                        error.name === 'InvalidParamsRpcError' ||\n                        error.name === 'MethodNotFoundRpcError' ||\n                        error.name === 'MethodNotSupportedRpcError') {\n                        return (await client\n                            .request({\n                            method: 'wallet_sendTransaction',\n                            params: [request],\n                        }, { retryCount: 0 })\n                            .then((hash) => {\n                            supportsWalletNamespace.set(client.uid, true);\n                            return hash;\n                        })\n                            .catch((e) => {\n                            const walletNamespaceError = e;\n                            if (walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                                walletNamespaceError.name === 'MethodNotSupportedRpcError') {\n                                supportsWalletNamespace.set(client.uid, false);\n                                throw error;\n                            }\n                            throw walletNamespaceError;\n                        }));\n                    }\n                    throw error;\n                }\n            })();\n            const receipt = await getAction(client, waitForTransactionReceipt, 'waitForTransactionReceipt')({\n                checkReplacement: false,\n                hash,\n                pollingInterval,\n                timeout,\n            });\n            if (throwOnReceiptRevert && receipt.status === 'reverted')\n                throw new TransactionReceiptRevertedError({ receipt });\n            return receipt;\n        }\n        if (account?.type === 'local') {\n            // Prepare the request for signing (assign appropriate fees, etc.)\n            const request = await getAction(client, prepareTransactionRequest, 'prepareTransactionRequest')({\n                account,\n                accessList,\n                authorizationList,\n                blobs,\n                chain,\n                data,\n                gas,\n                gasPrice,\n                maxFeePerBlobGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                nonce,\n                nonceManager: account.nonceManager,\n                parameters: [...defaultParameters, 'sidecars'],\n                type,\n                value,\n                ...rest,\n                to,\n            });\n            const serializer = chain?.serializers?.transaction;\n            const serializedTransaction = (await account.signTransaction(request, {\n                serializer,\n            }));\n            return (await getAction(client, sendRawTransactionSync, 'sendRawTransactionSync')({\n                serializedTransaction,\n                throwOnReceiptRevert,\n                timeout: parameters.timeout,\n            }));\n        }\n        if (account?.type === 'smart')\n            throw new AccountTypeNotSupportedError({\n                metaMessages: [\n                    'Consider using the `sendUserOperation` Action instead.',\n                ],\n                docsPath: '/docs/actions/bundler/sendUserOperation',\n                type: 'smart',\n            });\n        throw new AccountTypeNotSupportedError({\n            docsPath: '/docs/actions/wallet/sendTransactionSync',\n            type: account?.type,\n        });\n    }\n    catch (err) {\n        if (err instanceof AccountTypeNotSupportedError)\n            throw err;\n        throw getTransactionError(err, {\n            ...parameters,\n            account,\n            chain: parameters.chain || undefined,\n        });\n    }\n}\n//# sourceMappingURL=sendTransactionSync.js.map","/**\n * Requests for the wallet to show information about a call batch\n * that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus\n * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link ShowCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { showCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * await showCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function showCallsStatus(client, parameters) {\n    const { id } = parameters;\n    await client.request({\n        method: 'wallet_showCallsStatus',\n        params: [id],\n    });\n    return;\n}\n//# sourceMappingURL=showCallsStatus.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, AccountTypeNotSupportedError, } from '../../errors/account.js';\nimport { prepareAuthorization, } from './prepareAuthorization.js';\n/**\n * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.\n *\n * With the calculated signature, you can:\n * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,\n * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link SignAuthorizationParameters}\n * @returns The signed Authorization object. {@link SignAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function signAuthorization(client, parameters) {\n    const { account: account_ = client.account } = parameters;\n    if (!account_)\n        throw new AccountNotFoundError({\n            docsPath: '/docs/eip7702/signAuthorization',\n        });\n    const account = parseAccount(account_);\n    if (!account.signAuthorization)\n        throw new AccountTypeNotSupportedError({\n            docsPath: '/docs/eip7702/signAuthorization',\n            metaMessages: [\n                'The `signAuthorization` Action does not support JSON-RPC Accounts.',\n            ],\n            type: account.type,\n        });\n    const authorization = await prepareAuthorization(client, parameters);\n    return account.signAuthorization(authorization);\n}\n//# sourceMappingURL=signAuthorization.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { stringToHex, toHex, } from '../../utils/encoding/toHex.js';\n/**\n * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signMessage\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * With the calculated signature, you can:\n * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,\n * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.\n *\n * @param client - Client to use\n * @param parameters - {@link SignMessageParameters}\n * @returns The signed message. {@link SignMessageReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   message: 'hello world',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   message: 'hello world',\n * })\n */\nexport async function signMessage(client, { account: account_ = client.account, message, }) {\n    if (!account_)\n        throw new AccountNotFoundError({\n            docsPath: '/docs/actions/wallet/signMessage',\n        });\n    const account = parseAccount(account_);\n    if (account.signMessage)\n        return account.signMessage({ message });\n    const message_ = (() => {\n        if (typeof message === 'string')\n            return stringToHex(message);\n        if (message.raw instanceof Uint8Array)\n            return toHex(message.raw);\n        return message.raw;\n    })();\n    return client.request({\n        method: 'personal_sign',\n        params: [message_, account.address],\n    }, { retryCount: 0 });\n}\n//# sourceMappingURL=signMessage.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { assertCurrentChain, } from '../../utils/chain/assertCurrentChain.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { assertRequest, } from '../../utils/transaction/assertRequest.js';\nimport { getChainId } from '../public/getChainId.js';\n/**\n * Signs a transaction.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTransaction\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param args - {@link SignTransactionParameters}\n * @returns The signed serialized transaction. {@link SignTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTransaction } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTransaction } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function signTransaction(client, parameters) {\n    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;\n    if (!account_)\n        throw new AccountNotFoundError({\n            docsPath: '/docs/actions/wallet/signTransaction',\n        });\n    const account = parseAccount(account_);\n    assertRequest({\n        account,\n        ...parameters,\n    });\n    const chainId = await getAction(client, getChainId, 'getChainId')({});\n    if (chain !== null)\n        assertCurrentChain({\n            currentChainId: chainId,\n            chain,\n        });\n    const formatters = chain?.formatters || client.chain?.formatters;\n    const format = formatters?.transactionRequest?.format || formatTransactionRequest;\n    if (account.signTransaction)\n        return account.signTransaction({\n            ...transaction,\n            chainId,\n        }, { serializer: client.chain?.serializers?.transaction });\n    return await client.request({\n        method: 'eth_signTransaction',\n        params: [\n            {\n                ...format({\n                    ...transaction,\n                    account,\n                }, 'signTransaction'),\n                chainId: numberToHex(chainId),\n                from: account.address,\n            },\n        ],\n    }, { retryCount: 0 });\n}\n//# sourceMappingURL=signTransaction.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, } from '../../errors/account.js';\nimport { getTypesForEIP712Domain, serializeTypedData, validateTypedData, } from '../../utils/typedData.js';\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData(client, parameters) {\n    const { account: account_ = client.account, domain, message, primaryType, } = parameters;\n    if (!account_)\n        throw new AccountNotFoundError({\n            docsPath: '/docs/actions/wallet/signTypedData',\n        });\n    const account = parseAccount(account_);\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parameters.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    validateTypedData({ domain, message, primaryType, types });\n    if (account.signTypedData)\n        return account.signTypedData({ domain, message, primaryType, types });\n    const typedData = serializeTypedData({ domain, message, primaryType, types });\n    return client.request({\n        method: 'eth_signTypedData_v4',\n        params: [account.address, typedData],\n    }, { retryCount: 0 });\n}\n//# sourceMappingURL=signTypedData.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Switch the target chain in a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/switchChain\n * - JSON-RPC Methods: [`wallet_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)\n *\n * @param client - Client to use\n * @param parameters - {@link SwitchChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet, optimism } from 'viem/chains'\n * import { switchChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * await switchChain(client, { id: optimism.id })\n */\nexport async function switchChain(client, { id }) {\n    await client.request({\n        method: 'wallet_switchEthereumChain',\n        params: [\n            {\n                chainId: numberToHex(id),\n            },\n        ],\n    }, { retryCount: 0 });\n}\n//# sourceMappingURL=switchChain.js.map","/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/watchAsset\n * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)\n *\n * @param client - Client to use\n * @param parameters - {@link WatchAssetParameters}\n * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchAsset } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const success = await watchAsset(client, {\n *   type: 'ERC20',\n *   options: {\n *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *     decimals: 18,\n *     symbol: 'WETH',\n *   },\n * })\n */\nexport async function watchAsset(client, params) {\n    const added = await client.request({\n        method: 'wallet_watchAsset',\n        params,\n    }, { retryCount: 0 });\n    return added;\n}\n//# sourceMappingURL=watchAsset.js.map","import { sendTransactionSync, } from './sendTransactionSync.js';\nimport { writeContract } from './writeContract.js';\n/**\n * Executes a write function on a contract synchronously.\n * Returns the transaction receipt.\n *\n * - Docs: https://viem.sh/docs/contract/writeContractSync\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await writeContractSync(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n */\nexport async function writeContractSync(client, parameters) {\n    return writeContract.internal(client, sendTransactionSync, 'sendTransactionSync', parameters);\n}\n//# sourceMappingURL=writeContractSync.js.map","import { fillTransaction, } from '../../actions/public/fillTransaction.js';\nimport { getChainId, } from '../../actions/public/getChainId.js';\nimport { addChain, } from '../../actions/wallet/addChain.js';\nimport { deployContract, } from '../../actions/wallet/deployContract.js';\nimport { getAddresses, } from '../../actions/wallet/getAddresses.js';\nimport { getCallsStatus, } from '../../actions/wallet/getCallsStatus.js';\nimport { getCapabilities, } from '../../actions/wallet/getCapabilities.js';\nimport { getPermissions, } from '../../actions/wallet/getPermissions.js';\nimport { prepareAuthorization, } from '../../actions/wallet/prepareAuthorization.js';\nimport { prepareTransactionRequest, } from '../../actions/wallet/prepareTransactionRequest.js';\nimport { requestAddresses, } from '../../actions/wallet/requestAddresses.js';\nimport { requestPermissions, } from '../../actions/wallet/requestPermissions.js';\nimport { sendCalls, } from '../../actions/wallet/sendCalls.js';\nimport { sendCallsSync, } from '../../actions/wallet/sendCallsSync.js';\nimport { sendRawTransaction, } from '../../actions/wallet/sendRawTransaction.js';\nimport { sendRawTransactionSync, } from '../../actions/wallet/sendRawTransactionSync.js';\nimport { sendTransaction, } from '../../actions/wallet/sendTransaction.js';\nimport { sendTransactionSync, } from '../../actions/wallet/sendTransactionSync.js';\nimport { showCallsStatus, } from '../../actions/wallet/showCallsStatus.js';\nimport { signAuthorization, } from '../../actions/wallet/signAuthorization.js';\nimport { signMessage, } from '../../actions/wallet/signMessage.js';\nimport { signTransaction, } from '../../actions/wallet/signTransaction.js';\nimport { signTypedData, } from '../../actions/wallet/signTypedData.js';\nimport { switchChain, } from '../../actions/wallet/switchChain.js';\nimport { waitForCallsStatus, } from '../../actions/wallet/waitForCallsStatus.js';\nimport { watchAsset, } from '../../actions/wallet/watchAsset.js';\nimport { writeContract, } from '../../actions/wallet/writeContract.js';\nimport { writeContractSync, } from '../../actions/wallet/writeContractSync.js';\nexport function walletActions(client) {\n    return {\n        addChain: (args) => addChain(client, args),\n        deployContract: (args) => deployContract(client, args),\n        fillTransaction: (args) => fillTransaction(client, args),\n        getAddresses: () => getAddresses(client),\n        getCallsStatus: (args) => getCallsStatus(client, args),\n        getCapabilities: (args) => getCapabilities(client, args),\n        getChainId: () => getChainId(client),\n        getPermissions: () => getPermissions(client),\n        prepareAuthorization: (args) => prepareAuthorization(client, args),\n        prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),\n        requestAddresses: () => requestAddresses(client),\n        requestPermissions: (args) => requestPermissions(client, args),\n        sendCalls: (args) => sendCalls(client, args),\n        sendCallsSync: (args) => sendCallsSync(client, args),\n        sendRawTransaction: (args) => sendRawTransaction(client, args),\n        sendRawTransactionSync: (args) => sendRawTransactionSync(client, args),\n        sendTransaction: (args) => sendTransaction(client, args),\n        sendTransactionSync: (args) => sendTransactionSync(client, args),\n        showCallsStatus: (args) => showCallsStatus(client, args),\n        signAuthorization: (args) => signAuthorization(client, args),\n        signMessage: (args) => signMessage(client, args),\n        signTransaction: (args) => signTransaction(client, args),\n        signTypedData: (args) => signTypedData(client, args),\n        switchChain: (args) => switchChain(client, args),\n        waitForCallsStatus: (args) => waitForCallsStatus(client, args),\n        watchAsset: (args) => watchAsset(client, args),\n        writeContract: (args) => writeContract(client, args),\n        writeContractSync: (args) => writeContractSync(client, args),\n    };\n}\n//# sourceMappingURL=wallet.js.map","import { createClient, } from './createClient.js';\nimport { walletActions } from './decorators/wallet.js';\nexport function createWalletClient(parameters) {\n    const { key = 'wallet', name = 'Wallet Client', transport } = parameters;\n    const client = createClient({\n        ...parameters,\n        key,\n        name,\n        transport,\n        type: 'walletClient',\n    });\n    return client.extend(walletActions);\n}\n//# sourceMappingURL=createWalletClient.js.map"],"names":["AccountNotFoundError","BaseError","docsPath","AccountTypeNotSupportedError","metaMessages","type","assertCurrentChain","chain","currentChainId","ChainNotFoundError","ChainMismatchError","supportsWalletNamespace","LruMap","sendTransaction","client","parameters","account_","assertChainId","accessList","authorizationList","blobs","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","value","rest","account","parseAccount","assertRequest","to","recoverAuthorizationAddress","chainId","getAction","getChainId","chainFormat","_c","_b","_a","request","formatTransactionRequest","extract","isWalletNamespaceSupported","method","e","error","hash","walletNamespaceError","prepareTransactionRequest","defaultParameters","serializer","_d","serializedTransaction","sendRawTransaction","err","getTransactionError","writeContract","internal","actionFn","name","abi","address","args","dataSuffix","functionName","encodeFunctionData","getContractError","BundleFailedError","result","fallbackMagicIdentifier","fallbackTransactionErrorMagicIdentifier","numberToHex","sendCalls","capabilities","experimental_fallback","experimental_fallbackDelay","forceAtomic","id","version","calls","call_","call","concat","response","capability","message","UnsupportedNonOptionalCapabilityError","AtomicityNotSupportedError","promises","promise","hexToBigInt","resolve","results","r","hashes","getCallsStatus","getStatus","trim","sliceHex","receipts","status","hexToNumber","atomic","statusCode","receipt","receiptStatuses","waitForCallsStatus","pollingInterval","retryCount","retryDelay","count","timeout","throwOnFailure","observerId","stringify","reject","withResolvers","timer","unobserve","observe","emit","unpoll","poll","done","fn","withRetry","WaitForCallsStatusTimeoutError","addChain","nativeCurrency","rpcUrls","blockExplorers","url","deployContract","walletClient","bytecode","calldata","encodeDeployData","getAddresses","checksumAddress","getCapabilities","params","capabilities_raw","capabilities_","key","getPermissions","prepareAuthorization","executor","authorization","getTransactionCount","isAddressEqual","requestAddresses","getAddress","requestPermissions","permissions","sendCallsSync","sendTransactionSync","throwOnReceiptRevert","waitForTransactionReceipt","TransactionReceiptRevertedError","sendRawTransactionSync","showCallsStatus","signAuthorization","signMessage","message_","stringToHex","toHex","signTransaction","transaction","formatters","format","signTypedData","domain","primaryType","types","getTypesForEIP712Domain","validateTypedData","typedData","serializeTypedData","switchChain","watchAsset","writeContractSync","walletActions","fillTransaction","createWalletClient","transport","createClient"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]}