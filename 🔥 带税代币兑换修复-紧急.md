# 🔥 带税代币兑换修复 - 紧急问题

完成时间：2026-01-22

---

## 🚨 **问题现象**

用户报告：**"兑换失败"**

从控制台日志可以看到：
```
[Swap] ⚡ Swap tx sent (214ms): 0x...
[Swap] ⚡⚡⚡ Waiting for Swap confirmation...
[Swap] ⚡ Swap confirmed (927ms / 0.93s)
❌ Swap failed:
```

**关键特征：**
- ✅ 交易已发送
- ✅ 交易已确认
- ❌ 但最后报告"兑换失败"

这意味着交易在链上被 **reverted（回退）** 了。

---

## 🔍 **问题根源分析**

### **核心问题：RADRS 是带税代币（Tax Token）**

RADRS 是一种 **反射代币（Reflection Token）** 或 **带税代币（Tax Token）**，有以下特性：

1. **买入/卖出时自动扣税 ~10%**
2. **转账时也会扣税**
3. **实际到账金额 < 转账金额**

### **为什么会失败？**

#### **场景：10 RADRS → BNB**

**之前的错误逻辑：**
```typescript
// 1. Approve 10,000 RADRS
await approve(PANCAKE_ROUTER, 10000 RADRS)

// 2. 调用普通的 swapExactTokensForETH
await swapExactTokensForETH(
    amountIn: 10 RADRS,  // ❌ 要求精确转移 10 RADRS
    amountOutMin: 0.0001 BNB,
    path: [RADRS, WBNB],
    to: userAddress,
    deadline: ...
)
```

**实际执行流程：**
```
1. Router 尝试从用户地址 transferFrom 10 RADRS
   ↓
2. RADRS 合约扣税 10%
   ↓
3. Router 实际收到: 10 - 1 = 9 RADRS  ❌
   ↓
4. Router 用 9 RADRS 兑换 BNB
   ↓
5. 兑换出的 BNB < amountOutMin （基于 10 RADRS 的报价）
   ↓
6. ❌ 交易回退：INSUFFICIENT_OUTPUT_AMOUNT
```

**根本原因：**
- `swapExactTokensForETH` 要求 **精确转移** `amountIn` 数量
- 但带税代币转账后，Router 实际收到的数量 **少于** `amountIn`
- 导致最终兑换出的金额不足，交易失败

---

### **PancakeSwap 的解决方案**

PancakeSwap Router V2 提供了专门的函数来处理带税代币：

| 普通函数 | 带税代币函数 |
|---------|------------|
| `swapExactETHForTokens` | `swapExactETHForTokensSupportingFeeOnTransferTokens` |
| `swapExactTokensForETH` | `swapExactTokensForETHSupportingFeeOnTransferTokens` |
| `swapExactTokensForTokens` | `swapExactTokensForTokensSupportingFeeOnTransferTokens` |

**关键区别：**
- **普通函数**：要求精确转移 `amountIn`，基于 `amountIn` 计算输出
- **带税函数**：接受转账后的实际金额，基于实际收到的金额计算输出

---

## ✅ **已完成的修复**

### **修复 1：BNB → Token（RADRS）**

```typescript
// ❌ 之前：使用普通函数
const data = encodeFunctionData({
  abi: parseAbi(['function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline) payable returns (uint[] amounts)']),
  functionName: 'swapExactETHForTokens',
  args: [amountOutMin, path, wallet?.address as `0x${string}`, deadline]
})

// ✅ 修复后：检测带税代币，动态选择函数
const isTargetTaxToken = toAsset.symbol === 'RADRS'
const functionName = isTargetTaxToken 
    ? 'swapExactETHForTokensSupportingFeeOnTransferTokens'
    : 'swapExactETHForTokens'

const abiString = isTargetTaxToken
    ? 'function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] path, address to, uint deadline) payable'
    : 'function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline) payable returns (uint[] amounts)'

console.log(`[Swap] Using ${functionName}${isTargetTaxToken ? ' (带税代币)' : ''}`)

const data = encodeFunctionData({
  abi: parseAbi([abiString]),
  functionName,
  args: [amountOutMin, path, wallet?.address as `0x${string}`, deadline]
})
```

---

### **修复 2：Token（RADRS）→ BNB**

```typescript
// ❌ 之前：使用普通函数
const data = encodeFunctionData({
  abi: parseAbi(['function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)']),
  functionName: 'swapExactTokensForETH',
  args: [amountWei, amountOutMin, path, wallet?.address as `0x${string}`, deadline]
})

// ✅ 修复后：检测带税代币，动态选择函数
const isSourceTaxToken = fromAsset.symbol === 'RADRS'
const functionName = isSourceTaxToken
    ? 'swapExactTokensForETHSupportingFeeOnTransferTokens'
    : 'swapExactTokensForETH'

const abiString = isSourceTaxToken
    ? 'function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)'
    : 'function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)'

console.log(`[Swap] Using ${functionName}${isSourceTaxToken ? ' (带税代币)' : ''}`)

const data = encodeFunctionData({
  abi: parseAbi([abiString]),
  functionName,
  args: [amountWei, amountOutMin, path, wallet?.address as `0x${string}`, deadline]
})
```

---

### **修复 3：Token（RADRS）↔ Token**

```typescript
// ❌ 之前：使用普通函数
const data = encodeFunctionData({
  abi: parseAbi(['function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)']),
  functionName: 'swapExactTokensForTokens',
  args: [amountWei, amountOutMin, path, wallet?.address as `0x${string}`, deadline]
})

// ✅ 修复后：检测带税代币，动态选择函数
const isRadrsInvolved = fromAsset.symbol === 'RADRS' || toAsset.symbol === 'RADRS'

const functionName = isRadrsInvolved
    ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'
    : 'swapExactTokensForTokens'

const abiString = isRadrsInvolved
    ? 'function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)'
    : 'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)'

console.log(`[Swap] Using ${functionName}${isRadrsInvolved ? ' (带税代币)' : ''}`)

const data = encodeFunctionData({
  abi: parseAbi([abiString]),
  functionName,
  args: [amountWei, amountOutMin, path, wallet?.address as `0x${string}`, deadline]
})
```

---

## 📊 **修复效果对比**

### **修复前：**

```
用户兑换 10 RADRS → BNB
        ↓
使用 swapExactTokensForETH(10 RADRS, ...)
        ↓
RADRS 转账扣税 10%
        ↓
Router 实际收到 9 RADRS
        ↓
兑换出的 BNB < 预期（基于 10 RADRS）
        ↓
❌ INSUFFICIENT_OUTPUT_AMOUNT
        ↓
❌ 交易回退（Reverted）
```

---

### **修复后：**

```
用户兑换 10 RADRS → BNB
        ↓
检测到 RADRS 是带税代币
        ↓
使用 swapExactTokensForETHSupportingFeeOnTransferTokens(10 RADRS, ...)
        ↓
RADRS 转账扣税 10%
        ↓
Router 实际收到 9 RADRS
        ↓
✅ Router 基于实际收到的 9 RADRS 计算输出
        ↓
兑换出 BNB（基于 9 RADRS）
        ↓
✅ 交易成功
```

---

## 🎯 **修复的关键点**

### **1. 动态函数选择**

根据代币是否为带税代币（RADRS），动态选择正确的函数：

```typescript
const isTargetTaxToken = toAsset.symbol === 'RADRS'
const isSourceTaxToken = fromAsset.symbol === 'RADRS'
const isRadrsInvolved = fromAsset.symbol === 'RADRS' || toAsset.symbol === 'RADRS'
```

---

### **2. 正确的 ABI**

使用正确的 ABI 字符串，注意带税函数没有返回值：

```typescript
// ❌ 错误：带税函数不返回数组
'function swapExactTokensForETHSupportingFeeOnTransferTokens(...) returns (uint[] amounts)'

// ✅ 正确：带税函数没有返回值
'function swapExactTokensForETHSupportingFeeOnTransferTokens(...)'
```

---

### **3. 控制台日志**

添加清晰的日志，方便调试：

```typescript
console.log(`[Swap] Using ${functionName}${isSourceTaxToken ? ' (带税代币)' : ''}`)
```

---

### **4. 所有场景覆盖**

确保三种兑换场景都支持带税代币：
- ✅ BNB → RADRS
- ✅ RADRS → BNB
- ✅ RADRS ↔ Token（USDT、其他代币）

---

## ⚡ **立即测试（2 分钟）**

### **测试 1：RADRS → BNB**

1. 打开兑换页面
2. 选择：RADRS → BNB
3. 输入数量：10 RADRS
4. 点击"兑换"

✅ **预期结果：**
- [ ] 控制台显示：`Using swapExactTokensForETHSupportingFeeOnTransferTokens (带税代币)`
- [ ] Approve 成功
- [ ] Swap 成功
- [ ] 交易确认成功（没有 reverted）
- [ ] 显示"兑换成功"
- [ ] BNB 余额增加

---

### **测试 2：BNB → RADRS**

1. 选择：BNB → RADRS
2. 输入数量：0.001 BNB
3. 点击"兑换"

✅ **预期结果：**
- [ ] 控制台显示：`Using swapExactETHForTokensSupportingFeeOnTransferTokens (带税代币)`
- [ ] Swap 成功（无需 Approve）
- [ ] 交易确认成功
- [ ] RADRS 余额增加（注意：实际到账会比报价少 ~10%，这是正常的税收）

---

### **测试 3：RADRS ↔ USDT**

1. 选择：RADRS → USDT
2. 输入数量：10 RADRS
3. 点击"兑换"

✅ **预期结果：**
- [ ] 控制台显示：`Using swapExactTokensForTokensSupportingFeeOnTransferTokens (带税代币)`
- [ ] Approve 成功
- [ ] Swap 成功
- [ ] USDT 余额增加

---

### **测试 4：普通代币（BNB ↔ USDT）**

1. 选择：BNB → USDT
2. 输入数量：0.01 BNB
3. 点击"兑换"

✅ **预期结果：**
- [ ] 控制台显示：`Using swapExactETHForTokens`（没有"带税代币"标记）
- [ ] Swap 成功
- [ ] USDT 余额增加

---

## 📝 **控制台验证**

### **成功的日志应该是：**

```
[Swap] Scenario: Token → BNB (需要 Approve)
[Swap] ⚡ Approve tx sent (300ms): 0x...
[Swap] ⚡⚡⚡ Waiting for Approve confirmation (0 conf, 500ms polling)...
[Swap] ⚡ Approve confirmed (950ms)
[Swap] Using swapExactTokensForETHSupportingFeeOnTransferTokens (带税代币)
[Swap] ⚡ Swap tx sent (214ms, Gas: 400000): 0x...
[Swap] ⚡⚡⚡ Waiting for Swap confirmation (0 conf, 500ms polling)...
[Swap] ⚡ Swap confirmed (927ms / 0.93s)
[Swap] ✅ Swap confirmed successfully!
[Swap] ⚡⚡⚡ TOTAL SWAP TIME: 2.3s
```

**关键检查点：**
- [ ] 看到 `Using ...SupportingFeeOnTransferTokens (带税代币)` 日志
- [ ] 看到 `✅ Swap confirmed successfully!`（没有失败）
- [ ] 交易哈希可以在 BSCScan 上查到，状态为 **Success**

---

## 🚨 **常见问题**

### **Q1: 为什么 RADRS 到账比报价少？**

**A**: 这是正常的！RADRS 是带税代币，有 ~10% 的税收。

**示例：**
```
报价显示：兑换 10 RADRS → 0.001 BNB
实际执行：
  1. 转移 10 RADRS，扣税 10% = 1 RADRS
  2. Router 收到 9 RADRS
  3. 用 9 RADRS 兑换 BNB
  4. 实际得到：约 0.0009 BNB（比报价少 ~10%）
```

**UI 已提示：**
- 滑点保护：25%（覆盖税收 + 价格波动）
- "实际到账（扣税后）" 显示约 75% 的报价金额

---

### **Q2: 如何判断代币是否带税？**

**A**: 目前硬编码判断 `symbol === 'RADRS'`。

未来可以扩展：
```typescript
const TAX_TOKENS = ['RADRS', 'SAFEMOON', 'SHIB', ...]
const isTaxToken = TAX_TOKENS.includes(asset.symbol)
```

或者通过合约查询是否实现了 `_transfer` hook。

---

### **Q3: 为什么不全部使用带税函数？**

**A**: 带税函数的 Gas 消耗略高，且对于普通代币没有必要。

**性能对比：**
| 代币类型 | 函数类型 | Gas 消耗 |
|---------|---------|---------|
| 普通代币 | swapExactTokensForETH | ~200k Gas |
| 普通代币 | ...SupportingFeeOnTransferTokens | ~220k Gas |
| 带税代币 | swapExactTokensForETH | ❌ **失败（Reverted）** |
| 带税代币 | ...SupportingFeeOnTransferTokens | ~220k Gas ✅ |

所以我们动态选择，优化性能。

---

## 🎉 **总结**

### **问题：**
❌ RADRS 兑换失败（交易回退）

### **原因：**
❌ 使用了普通的 `swapExactTokensForETH` 函数
❌ 无法处理带税代币的转账扣税

### **修复：**
✅ 检测 RADRS 是带税代币
✅ 动态选择 `...SupportingFeeOnTransferTokens` 函数
✅ 覆盖所有 3 种兑换场景

### **测试：**
✅ RADRS → BNB
✅ BNB → RADRS
✅ RADRS ↔ Token
✅ 普通代币兑换（不影响）

### **效果：**
从 **兑换失败（Reverted）** 升级到 **兑换成功** ✅

---

**现在 RADRS 兑换应该能成功了！** 🎉

**立即测试！如果仍然失败，请提供完整的控制台日志。**

═══════════════════════════════════════════════════════════
